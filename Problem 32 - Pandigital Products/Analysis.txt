// assign each variable to either multiplicand, multiplier or product set
// {a} x {b} = {c} with {a} and {b} being assigned and c being the remainder
// permutate each set and compute equivalence
// cache product 

/*
In {{{}}, {1, 2, ... , n}}
Return {{{1}}, {2, ... , n}}

In {{1}, {2, ... , n}}
Return {{{1, 2}, {2, 1}}, {3 , ... , n}}

In {{{1, 2}, {2, 1}}, {3 , ... , n}} 
Return {{{1, 2, 3}, ... , {2, 1, 3}}, {4 , ... , n}}

... 

In {{{1, ... , n} , ... , {n , ... , 1}}, {{}}}

-----------------------------------------------------------------------------
Pseudocode:
In {A := {{}}, B:= {1, 2, ... , n}}
K := A.size
N := B.size 

for(i = 0 to (K - 1)!)
	# want to iterate over every set in A
	for(j = 0 to N
	need inverse factorial as we are given a set of k items s.t. n! = k, need to then iterate over each set k n times

	A.at(i).at(j)

Notes:
num subsets in A = (n - k)!
when taking B[0] could order the list backwards and pop back 
order doesnt matter so could just pop as normal 

-----------------------------------------------------------------------------
Example																		
IN {{{1, 2}, {2, 1}}, {3, 4, ... , n}}										
K := 2																		
N := n - 2																																			
take 3 from {3, 4, ... , n}}												
i E {0, 1}																	
need to insert 3 in (K+1)! places											
0 1 2 in {}i = 0															
0 1 2 in {}i = 1																															
j mod 3 with j E {0, ..., 5}																										
remove B_0																	
not empty -> return {{{1, 2, 3}, {1, 3, 2,}, ...} , {4, 5, ... , n}}		
Return {{{1, 2, 3}, {1, 3, 2,}, ...} , {4, 5, ... , n}}	
-----------------------------------------------------------------------------
Generalising

permutations In {A := {{...}, {...}} , B := {... , n - 1, n}} A is the permutated subsets, B is elements left to permutate
K := Size of A ( number of sets it contains )
N := n - K / size of B <- More general
If N = 0 
	return A
Else 
	take B_0 from B <- This is the next element that will be "added" to the permutations
	i in 0 to K-1 <- i is for sets 
	j in 0 to (K+1)! - 1 is for the position in the set A_i where the element B_0 should be placed
	i = j = 0
	while i < K - 1
		create new empty set
		if j mod (K+1) = 0 incrimiment i
		if i = j, empty set push back B_0
		else empty set push back A_0_j // check index
	remove the element B_0 that was "added"
	return permutations {{new permutations sets}, B \ B_0}
*/